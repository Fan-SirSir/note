# 初识Node.js与内置模块

## node.js

### 1. 什么是 Node.js

>Node.js® is a **JavaScript runtime** built on Chrome's V8 JavaScript engine.****
>**Node.js** 是一个基于 Chrome V8 引擎的 **JavaScript 运行环境。**

### 2. Node.js 中的  JavaScript 运行环境

![](ph/Node/Snipaste_2023-07-03_14-49-11.png)

### 3. 用途

①  基于 Express 框架（http://www.expressjs.com.cn/），可以快速构建 Web 应用

②  基于 Electron 框架（https://electronjs.org/），可以构建跨平台的桌面应用

③  基于 restify 框架（http://restify.com/），可以快速构建 API 接口项目

④  读写和操作数据库、创建实用的命令行工具辅助前端开发、etc…

### 4. Node.js环境的安装

>如果希望通过 Node.js 来运行 Javascript 代码，则必须在计算机上安装 Node.js 环境才行。

安装包可以从 Node.js 的官网首页直接下载，进入到 Node.js 的官网首页（**https://nodejs.org/en/**），点击绿色的按钮，下载所需的版本后，双击直接安装即可。

**区分** **LTS** **版本和** **Current** **版本的不同**

①LTS 为长期稳定版，对于**追求稳定性**的**企业级项目**来说，推荐安装 LTS 版本的 Node.js。

②Current 为新特性尝鲜版，对**热衷于尝试新特性**的用户来说，推荐安装 Current 版本的 Node.js。但是，Current 版本中可能存在隐藏的 Bug 或安全性漏洞，因此不推荐在企业级项目中使用 Current 版本的 Node.js。

### 5. 终端的快捷键

> 在 Windows 的 powershell 或 cmd 终端中，我们可以通过如下快捷键，来提高终端的操作效率：

①使用 **↑** 键，可以快速定位到上一次执行的命令

②使用 **tab** 键，能够快速补全路径

③使用 **esc** 键，能够快速清空当前已输入的命令

④输入 **cls** 命令，可以清空终端

## 内置模块

### 文件系统模块

#### 什么是 fs 文件系统模块

> **fs 模块**是 Node.js 官方提供的、用来操作文件的模块。它提供了一系列的方法和属性，用来满足用户对文件的操作需求。

例如:

-  **fs.readFile()** 方法，用来**读取**指定文件中的内容
-  **fs.writeFile()** 方法，用来向指定的文件中**写入**内容

如果要在 JavaScript 代码中，使用 fs 模块来操作文件，则需要使用如下的方式先导入它:

```js
const fs = require('fs')
```

#### 读取指定文件中的内容

##### 1. fs.readFile() 的语法格式

> 使用 fs.readFile() 方法，可以读取指定文件中的内容，语法格式如下：

![](ph/Node/Snipaste_2023-07-05_15-47-18.png)

##### 2. fs.readFile() 的示例代码

> 以 utf8 的编码格式，读取指定文件的内容，并打印 err 和 dataStr 的值：

```js
const fs = require('fs')
	
fs.readFile('./files/3.txt', 'utf8', function(err, dataStr) {
  console.log(err)
  console.log('-------')
  console.log(dataStr)
})
```

##### 3, 判断文件是否读取成功

> 可以判断 err 对象是否为 null，从而知晓文件读取的结果：

```js
// 1. 导入 fs 模块，来操作文件
const fs = require('fs')

// 2. 调用 fs.readFile() 方法读取文件
fs.readFile('./files/3.txt', 'utf8', function(err, dataStr) {
  // 2.1 打印失败的结果
  // 如果读取成功，则 err 的值为 null
  // 如果读取失败，则 err 的值为 错误对象，dataStr 的值为 undefined
  console.log(err)
  console.log('-------')
  // 2.2 打印成功的结果
  console.log(dataStr)
})

```

#### 向指定的文件中写入内容

##### 1. fs.writeFile() 的语法格式

> 使用 fs.writeFile() 方法，可以向指定的文件中写入内容，语法格式如下：

![](ph/Node/Snipaste_2023-07-05_15-48-03.png)

##### 2.  fs.writeFile() 的示例代码

![](ph/Node/Snipaste_2023-07-05_15-49-28.png)

##### 3. 判断文件是否写入成功

![](ph/Node/Snipaste_2023-07-05_15-51-42.png)

#### fs 模块 - 路径动态拼接的问题

> 在使用 fs 模块操作文件时，如果提供的操作路径是以 ./ 或 ../ 开头的**相对路径**时，很容易出现路径动态拼接错误的问题。 原因：代码在运行的时候，**会以执行 node 命令时所处的目录**，动态拼接出被操作文件的完整路径。

解决方案：![](ph/Node/Snipaste_2023-07-05_15-58-02.png)

### path路径模块

> **path 模块**是 Node.js 官方提供的、用来**处理路径**的模块。它提供了一系列的方法和属性，用来满足用户对路径的处理 需求。

例如:

-  **path.join()** 方法，用来**将多个路径片段拼接成一个完整的路径字符串** 
-  **path.basename()** 方法，用来从路径字符串中，将文件名解析出来

> 如果要在 JavaScript 代码中，使用 path 模块来处理路径，则需要使用如下的方式先导入它：

`const path = require('path')`

#### 路径拼接

##### 1. path.join() 的语法格式

> 使用 path.join() 方法，可以把多个路径片段拼接为完整的路径字符串，语法格式如下：

`path.join([...paths])`

参数解读:

-  ...paths  路径片段的序列
- 返回值: string

##### 2.  path.join() 的代码示例代码示例

> 使用 path.join() 方法，可以把多个路径片段拼接为完整的路径字符串：

![](ph/Node/Snipaste_2023-07-05_21-28-52.png)

#### 获取路径中的文件名

##### 1.  path.basename() 的语法格式

> 使用 path.basename() 方法，可以获取路径中的最后一部分，经常通过这个方法获取路径中的文件名，语法格式如下：

![](ph/Node/Snipaste_2023-07-05_21-30-33.png)

##### 2. path.basename() 的代码示例

![](ph/Node/Snipaste_2023-07-05_21-32-02.png)

#### 获取路径中的文件扩展名

##### 1. path.extname() 的语法格式

![](ph/Node/Snipaste_2023-07-05_21-33-35.png)

##### 2. path.extname() 的代码示例

![](ph/Node/Snipaste_2023-07-05_21-34-19.png)

### http模块

> **http 模块**是 Node.js 官方提供的、用来**创建 web 服务器**的模块。通过 http 模块提供的 **http.createServer()** 方法，就 能方便的把一台普通的电脑，变成一台 Web 服务器，从而对外提供 Web 资源服务。

**如果要希望使用 http 模块创建 Web 服务器，则需要先导入它：**

`const http = require('http')`

#### http 模块的作用

> 服务器和普通电脑的**区别**在于，服务器上安装了 **web 服务器软件**，例如：IIS、**Apache** 等。通过安装这些服务器软件， 就能把一台普通的电脑变成一台 web 服务器。
>
> 在 Node.js 中，我们**不需要使用** IIS、Apache 等这些**第三方 web 服务器软件**。因为我们可以基于 Node.js 提供的 http 模块，**通过几行简单的代码，就能轻松的手写一个服务器软件**，从而对外提供 web 服务

## 服务器相关概念

### 1. ip 地址

> **IP 地址**就是互联网上**每台计算机的唯一地址**，IP 地址的格式：通常用**“点分十进制”**表示成**（a.b.c.d）**的形式，其中，a,b,c,d 都是 0~255 之间的十进制整数。例如：用 点分十进表示的 IP地址（192.168.1.1）

注意： 在开发期间，自己的电脑既是一台服务器，也是一个客户端，为了方便测试，可以在自己的浏览器中输入 127.0.0.1 这个 IP 地址，就能把自己的电脑当做一台服务器进行访问了。

### 2. 域名和域名服务器

> 域名是**字符型**的**地址方案**，即所谓的**域名（Domain Name）地址**
>
> **iP地址**和**域名**是**一一对应的关系**，这份对应关系存放在一种叫做**域名服务器**(DNS，Domain name server)的电脑中。**域名服务器就是提供 IP 地址和域名 之间的转换服务的服务器。**

### 3. 端口号

> 在一台电脑中，可以运行成百上千个 web 服务。每个 web 服务都对应一个唯一的端口号。客户端发送过来的 网络请求，通过端口号，可以被准确地交给**对应的 web 服务**进行处理。

![](ph/Node/Snipaste_2023-07-07_17-29-09.png)

### 4. 创建最基本的 web 服务器	

#### 1. 导入 http 模块

`const http = require('http')`

#### 2.  创建 web 服务器实例

`create server = http.createServer()`

#### 3. 为服务器实例绑定 request 事件

> 为服务器实例绑定 request 事件，即可监听客户端发送过来的网络请求

![](ph/Node/Snipaste_2023-07-07_17-55-18.png)

#### 4. 启动服务

> 调用服务器实例的 .listen() 方法，即可启动当前的 web 服务器实例

![](ph/Node/Snipaste_2023-07-07_17-56-18.png)

#### 5 req 请求对象

> 只要服务器接收到了客户端的请求，就会调用通过 **server.on()** 为服务器绑定的 **request 事件处理函数**。 如果想在事件处理函数中，访问与**客户端**相关的**数据或属性**，可以使用如下的方式：

![](ph/Node/Snipaste_2023-07-07_18-03-06.png)

#### 6.  res 响应对象

> 在服务器的 request 事件处理函数中，如果想访问与**服务器**相关的**数据或属性**，可以使用如下的方式：

![](ph/Node/Snipaste_2023-07-07_18-06-28.png)

#### 7. 解决中文乱码问题

> 当调用 res.end() 方法，向客户端发送中文内容的时候，会出现乱码问题，此时，需要手动**设置内容的编码格式**

![](ph/Node/Snipaste_2023-07-07_18-07-57.png)

### 5. 根据不同的 url 响应不同的 html 内容

#### 1. 核心实现步骤 

① 获取**请求的 url 地址** 

② 设置**默认的响应内容**为 404 Not found

 ③ 判断用户请求的是否为 **/** 或 **/index.html** 首页 

④ 判断用户请求的是否为 **/about.html** 关于页面 

⑤ 设置 **Content-Type 响应头**，防止中文乱码

 ⑥ 使用 **res.end()** 把内容响应给客户端

#### 2. 动态响应内容

![](ph/Node/Snipaste_2023-07-07_18-10-24.png)

# 模块化

## 模块化的基本概念

>**遵守固定的规则**，把一个**大文件**拆成**独立并互相依赖**的**多个小模块。**

**把代码进行模块化拆分的好处：**

①  提高了代码的**复用性**

②  提高了代码的**可维护性**

③  可以实现**按需加载**

### 模块化规范

> **模块化规范**就是对代码进行模块化的拆分与组合时，需要遵守的那些规则。

例如：

- 使用什么样的语法格式来引用模块
- 在模块中使用什么样的语法格式向外暴露成员

**模块化规范的好处**：降低了沟通的成本，极大方便了各个模块之间的相互调用

## Node.js中模块化

### 分类

Node.js 中根据模块来源的不同，将模块分为了 3 大类，分别是：

- **内置模块**（内置模块是由 Node.js 官方提供的，例如 fs、path、http 等）
-  **自定义模块**（用户创建的每个 .js 文件，都是自定义模块）
- **第三方模块**（由第三方开发出来的模块，并非官方提供的内置模块，也不是用户创建的自定义模块，使用前需要先下载）

### 加载模块

> 使用强大的 **require()** 方法，可以加载需要的**内置模块、用户自定义模块、第三方模块**进行使用。例如：

![](ph/Node/02_模块化_page9_image.png)

**注意：**使用 require() 方法加载其它模块时，会执行被加载模块中的代码。

### 模块作用域

#### 1. 什么是模块作用域

>和**函数作用域**类似，在自定义模块中定义的**变量、方法**等成员，**只能在当前模块内被访问**，这种**模块级别的访问限制**，叫做**模块作用域。**

#### 2. 模块作用域的好处

> 防止了全局变量污染的问题

### 向外共享模块作用域中的成员

#### 1. module 对象

在每个 .js 自定义模块中都有一个 module 对象，它里面存储了和当前模块有关的信息，打印如下：

![](ph/Node/02_模块化_page12_image.png)

#### 2. module.exports 对象

>在自定义模块中，可以使用 module.exports 对象，将模块内的成员共享出去，供外界使用。 
>外界用 **require()** 方法导入自定义模块时，得到的就是 module.exports 所指向的对象。

#### 3. 共享成员时的注意点

使用 require() 方法导入模块时，导入的结果，==永远以  module.exports 指向的对象为准。==

#### 4. exports 对象

>由于 module.exports 单词写起来比较复杂，为了简化向外共享成员的代码，Node 提供了 **exports** 对象。**默认情况** 
>**下，exports 和 module.exports 指向同一个对象**。最终共享的结果，还是以 module.exports 指向的对象为准。

![](ph/Node/02_模块化_page15_image.png)

> 在 CommonJS 中，使用 `exports` 导出模块时，如果要引入模块中的某个具体成员（比如函数、变量等），需要使用 `{}` 将该成员名括起来，表示只引入该成员，而不是整个模块。例如：

```js
// 导出模块
exports.foo = function() {...}
exports.bar = function() {...}

// 引入模块中的具体成员
const { foo } = require('module')
foo()

`这里使用了 {} 将 foo 括起来，表示只引入 foo 这个函数。`
```

> 如果你只是想导出一些函数或变量，那么使用`exports`更加方便。但是，如果你想要导出一个类或构造函数，则必须使用`module.exports`。	

#### 5. exports 和  module.exports 的使用误区

> 时刻谨记，require() 模块时，得到的永远是 **module.exports** 指向的对象：

![](ph/Node/Snipaste_2023-07-07_20-01-56.png)

#### 6. `exports`和`module.exports`区别

> `module.exports`指向的是真正的导出对象，而`exports`只是对`module.exports`的一个全局引用

- 因此，当你想要导出一个单独的函数或对象时，可以使用`exports`，例如：

  ```js
  // 导出单个函数
  exports.myFunction = function() {
    // ...
  };
  
  // 导出单个对象
  exports.myObject = {
    // ...
  };
  
  ```

- 如果你想要导出一个构造函数或类，或者想要覆盖整个模块的导出对象，那么应该使用`module.exports`，例如：

  ```js
  // 导出构造函数
  module.exports = function() {
    // ...
  };
  
  // 覆盖整个导出对象
  module.exports = {
    // ...
  };
  
  ```

  ==总结:==如果你只是想导出一些函数或对象，可以使用`exports`。但是，如果你需要更多的灵活性和控制权，应该使用`module.exports`

### Node.js 中的模块化规范

> Node.js 遵循了 CommonJS 模块化规范，CommonJS 规定了**模块的特性**和**各模块之间如何相互依赖。**

CommonJS 规定：

①  每个模块内部，**module 变量**代表当前模块。

②  module 变量是一个对象，它的 exports 属性（即 **module.exports**）**是对外的接口。**

③  加载某个模块，其实是加载该模块的 module.exports 属性。**require() 方法用于加载模块。**

## npm与包

### 包

#### 1. 什么是包

>Node.js 中的**第三方模块**又叫做**包**。
>就像**电脑**和**计算机**指的是相同的东西，**第三方模块**和**包**指的是同一个概念，只不过叫法不同。

#### 2. 包的来源

> 不同于 Node.js 中的内置模块与自定义模块，**包是由第三方个人或团队开发出来的**，免费供所有人使用。

#### 3. 为什么需要包

>由于 Node.js 的内置模块仅提供了一些底层的 API，导致在基于内置模块进行项目开发的时，效率很低。 
>**包是基于内置模块封装出来的**，提供了更高级、更方便的 API，**极大的提高了开发效率**。
>**包**和**内置模块**之间的关系，类似于 **jQuery** 和 **浏览器内置 API** 之间的关系。

#### 4. 从哪里下载包

>国外有一家 IT 公司，叫做 npm, Inc. 这家公司旗下有一个非常著名的网站： https://www.npmjs.com/ ，它是全球最 
>大的包共享平台，你可以从这个网站上搜索到任何你需要的包，只要你有足够的耐心！

### npm初体验

#### 1. 在项目中安装包的命令

`npm install 包的完整名称`

简写:`npm i 完整的包名称`

#### 2. 安装指定版本的包

默认情况下，使用 npm install 命令安装包的时候，会自动安装最新版本的包。如果需要安装指定版本的包，可以在包 
名之后，通过 @ 符号指定具体的版本，例如：

`npm i moment@2.22.2`

#### 3. 包的语义化规范

包的版本号是以“点分十进制”形式进行定义的，总共有三位数字，例如 **2.24.0** 
其中每一位数字所代表的的含义如下：

第1位数字：**大版本**


第2位数字：**功能版本** 

第3位数字：Bug修复版本

**版本号提升的规则：**只要前面的版本号增长了，则后面的版本号**归零**。

#### 4. 初次装包后多了哪些文件

初次装包完成后，在项目文件夹下多一个叫做 node_modules 的文件夹和 package-lock.json 的配置文件。


其中：

**node_modules 文件夹**用来**存放所有已安装到项目中的包**。require() 导入第三方包时，就是从这个目录中查找并加载包。

**package-lock.json 配置文件**用来**记录 node_modules 目录下的每一个包的下载信息**，例如包的名字、版本号、下载地址等

#### 5. 安装指定版本的包

> 默认情况下，使用 npm install 命令安装包的时候，**会自动安装最新版本的包**。如果需要安装指定版本的包，可以在包 名之后，通过 **@ 符号**指定具体的版本，例如：

`npm i moment@2.22.2`

#### 6. 包的语义化版本规范

包的版本号是以“点分十进制”形式进行定义的，总共有三位数字，例如 **2.24.0** 

其中每一位数字所代表的的含义如下：

 第1位数字：**大版本** 

第2位数字：**功能版本** 

第3位数字：Bug修复版本 

**版本号提升的规则**：只要前面的版本号增长了，则后面的版本号**归零**

### 包管理配置文件

> npm 规定，在**项目根目录**中，**必须**提供一个叫做 **package.json** 的包管理配置文件。用来记录与项目有关的一些配置 信息。例如：

- 项目的名称、版本号、描述等 
-  项目中都用到了哪些包 
-  哪些包只在**开发期间**会用到 
- 那些包在**开发**和**部署**时都需要用到

#### 1. 如何记录项目中安装了哪些包

> **在项目根目录中**，创建一个叫做 **package.json** 的配置文件，即可用来记录项目中安装了哪些包。从而方便剔除 node_modules 目录之后，在团队成员之间共享项目的源代码。

**注意**：今后在项目开发中，一定要把 node_modules 文件夹，添加到 .gitignore 忽略文件中

#### 2. 快速创建 package.json

> npm 包管理工具提供了一个**快捷命令**，可以在**执行命令时所处的目录中**，快速创建 package.json 这个包管理 配置文件：

`npm init -y`

注意:

① 上述命令**只能在英文的目录下成功运行**！所以，项目文件夹的名称一定要使用英文命名，**不要使用中文，不能出现空格。** 

② 运行 npm install 命令安装包的时候，npm 包管理工具会自动把**包的名称**和**版本号**，记录到 package.json 中。

#### 3. dependencies 节点

> package.json 文件中，有一个 **dependencies** 节点，专门用来记录使用 npm install  命令安装了哪些包。

#### 4. 一次性安装所有的包

> 可以运行 npm install 命令（或 npm i）一次性安装所有的依赖包：

![](ph/Node/Snipaste_2023-07-09_10-43-12.png)

#### 5. 卸载包

> 可以运行 **npm uninstall** 命令，来卸载指定的包：

**注意：**npm uninstall 命令执行成功后，会把卸载的包，自动从 package.json 的 dependencies 中移除掉。

#### 6. devDependencies 节点

> 如果某些包**只在项目开发阶段**会用到，在**项目上线之后不会用到**，则建议把这些包记录到 devDependencies 节点中。 与之对应的，如果某些包在**开发**和**项目上线之后**都需要用到，则建议把这些包记录到 dependencies 节点中。

![](ph/Node/Snipaste_2023-07-09_10-45-43.png)

### 解决下包速度慢的问题

#### 1. 为什么下包速度慢

在使用 npm 下包的时候，默认从国外的 https://registry.npmjs.org/ 服务器进行下载，此时，网络数据的传输需要经 过漫长的海底光缆，因此下包速度会很慢。

#### 2. 淘宝 NPM 镜像服务器

![](ph/Node/Snipaste_2023-07-09_10-48-32.png)

#### 3.  切换 npm 的下包镜像源

> 下包的镜像源，指的就是**下包的服务器地址**

![](ph/Node/Snipaste_2023-07-09_10-50-03.png)

#### 4. nrm

> 为了更方便的切换下包的镜像源，我们可以安装 **nrm** 这个小工具，利用 nrm 提供的终端命令，可以快速查看和切换下 包的镜像源

![](ph/Node/Snipaste_2023-07-09_10-51-19.png)

### 包的分类

> 使用 npm 包管理工具下载的包，共分为两大类，分别是：

- 项目包
- 全局包

#### 1. 项目包

> 那些被安装到**项目**的 **node_modules** 目录中的包，都是项目包。

项目包又分为两类，分别是：

-  **开发依赖包**（被记录到 **devDependencies** 节点中的包，只在开发期间会用到） 
-  **核心依赖包**（被记录到 **dependencies** 节点中的包，在开发期间和项目上线之后都会用到）

![](ph/Node/Snipaste_2023-07-09_10-56-42.png)

#### 2. 全局包

> 在执行 npm install 命令时，如果提供了 **-g** 参数，则会把包安装为**全局包。**

![](ph/Node/Snipaste_2023-07-09_10-57-48.png)

#### 3. i5ting_toc

> i5ting_toc 是一个可以把 md 文档转为 html 页面的小工具，使用步骤如下：

![](ph/Node/Snipaste_2023-07-09_10-58-51.png)

###  规范的包结构

一个规范的包，它的组成结构，必须符合以下 3 点要求：

① 包必须以**单独的目录**而存在 

② 包的顶级目录下要必须包含 **package.json** 这个包管理配置文件 

③ package.json 中必须包含 **name，version，main** 这三个属性，分别代表**包的名字、版本号、包的入口**。

注意：以上 3 点要求是一个规范的包结构必须遵守的格式，关于更多的约束，可以参考如下网址： https://yarnpkg.com/zh-Hans/docs/package-json

## 模块的加载机制

### 优先从缓存中加载

>**模块在第一次加载后会被缓存**。 这也意味着多次调用 **require()** 不会导致模块的代码被执行多次。
>注意：不论是内置模块、用户自定义模块、还是第三方模块，它们都会优先从缓存中加载，从而**提高模块的加载效率**

### 自定义模块的加载机制

> 使用 require() 加载自定义模块时，必须指定以 **./** 或 **../** 开头的**路径标识符**。在加载自定义模块时，如果没有指定 ./ 或 ../ 
> 这样的路径标识符，则 node 会把它当作**内置模块**或**第三方模块**进行加载

同时，在使用 require() 导入自定义模块时，如果省略了文件的扩展名，则 Node.js 会**按顺序**分别尝试加载以下的文件：

①  按照**确切的文件名**进行加载

②  补全 **.js** 扩展名进行加载

③  补全 **.json** 扩展名进行加载

④  补全 **.node** 扩展名进行加载

⑤  加载失败，终端报错

### 目录作为模块

当把目录作为模块标识符，传递给 require() 进行加载的时候，有三种加载方式：

①  在被加载的目录下查找一个叫做 package.json 的文件，并寻找 main 属性，作为 require() 加载的入口

② 如果目录里没有 package.json 文件，或者 main 入口不存在或无法解析，则 Node.js 将会试图加载目录下的 **index.js 文件。**

③  如果以上两步都失败了，则 Node.js 会在终端打印错误消息，报告模块的缺失：Error: Cannot find module 'xxx'

# Express

## 初识 Express

### 1. 什么是 Express

> Express 的作用和 Node.js 内置的 http 模块类似，**是专门用来创建 Web 服务器的**
>
> **Express 的本质**：就是一个 npm 上的第三方包，提供了快速创建 Web 服务器的便捷方法。

### 2. Expres 能做什么

对于前端程序员来说，最常见的**两种**服务器，分别是：

- **Web 网站服务器**：专门对外提供 Web 网页资源的服务器。 
- **API 接口服务器：**专门对外提供 API 接口的服务器。 使用 Express，我们可以方便、快速的创建 **Web 网站**的服务器或 **API 接口**的服务器。

### Express 的基本使用

#### 1. 安装

> 在项目所处的目录中，运行如下的终端命令，即可将 express 安装到项目中使用:

`npm i express@4.17.1`

#### 2. 创建基本的 Web 服务器

![](ph/Node/Snipaste_2023-07-09_09-29-38.png)

#### 3. 监听 GET 请求

> 通过 app.get() 方法，可以监听客户端的 GET 请求，具体的语法格式如下：

![](ph/Node/Snipaste_2023-07-09_09-30-40.png)

#### 4. 监听 POST 请求

> 通过 app.post() 方法，可以监听客户端的 POST 请求，具体的语法格式如下

![](ph/Node/Snipaste_2023-07-09_09-31-17.png)

#### 5. 把内容相应给客户端

> 通过 res.send() 方法，可以把处理好的内容，发送给客户端：

![](ph/Node/Snipaste_2023-07-09_09-32-18.png)

#### 6. 获取 URL 中携带的查询参数

> 通过 **req.query** 对象，可以访问到客户端通过**查询字符串**的形式，发送到服务器的参数：

![](ph/Node/Snipaste_2023-07-09_09-33-05.png)

#### 7. 获取 URL 中的动态参数

> 通过 req.params 对象，可以访问到 URL 中，通过 : 匹配到的动态参数:

![](ph/Node/Snipaste_2023-07-09_09-33-46.png)

### 托管静态资源

#### 1. express.static()

> express 提供了一个非常好用的函数，叫做 **express.static()**,通过它可以非常方便地创建一个静态资源服务器，
>
> 例如，通过如下代码就可以将 public 目录下的图片、CSS 文件、JavaScript 文件对外开放访问了：

![](ph/Node/Snipaste_2023-07-09_09-41-39.png)

#### 2. 托管多个静态资源目录

![](ph/Node/Snipaste_2023-07-09_09-47-05.png)

> 注意: 如果包含相同文件,则自动按先后顺序选择使用的文件

#### 3. 挂载路径前缀

> 如果希望在托管的**静态资源访问路径**之前，**挂载路径前缀**，则可以使用如下的方式：

![](ph/Node/Snipaste_2023-07-09_09-49-25.png)

### nodemon

#### 1. 使用 nodemon 的好处

> nodemon（https://www.npmjs.com/package/nodemon） 这个工具，它能够**监听项目文件 的变动**，当代码被修改后，nodemon 会**自动帮我们重启项目**，极大方便了开发和调试

#### 2. 安装 nodemon

> 在终端中，运行如下命令，即可将 nodemon 安装为全局可用的工具：

`npm install -g nodemon`

#### 3. 使用 nodemon

> 将 node 命令替换为 nodemon 命令，使用 **nodemon 文件名称**样做的好处是：代码 被修改之后，会被 nodemon 监听到，从而实现自动重启项目的效果。

```js
nodemon 文件名称
```



## Express 路由

### 路由的概念

> 路由就是**映射关系**

####  1. Express 中的路由

> 在 Express 中，路由指的是**客户端的请求**与**服务器处理函数**之间的**映射关系**。 Express 中的路由分 3 部分组成，分别是**请求的类型、请求的 URL 地址、处理函数**，格式如下：

`app.METHOD(PATH,HANDLER)`

#### 2. Express 中的路由的例子

![Snipaste_2023-07-10_14-21-03](ph/Node/Snipaste_2023-07-10_14-21-03.png)

#### 3. 路由的匹配过程

> 每当一个请求到达服务器之后，**需要先经过路由的匹配**，只有匹配成功之后，才会调用对应的处理函数。 在匹配时，会按照路由的顺序进行匹配，如果**请求类型**和**请求的 URL** 同时匹配成功，则 Express 会将这次请求，转 交给对应的 function 函数进行处理。

![](ph/Node/Snipaste_2023-07-10_14-24-43.png)

### 路由的使用

#### 1.  最简单的用法

> 在 Express 中使用路由最简单的方式，就是把路由挂载到 app 上，示例代码如下：

![](ph/Node/Snipaste_2023-07-10_14-28-44.png)

#### 2. 模块化路由

> 为了方便对路由进行模块化的管理，Express **不建议**将路由直接挂载到 app 上，而是**推荐将路由抽离为单独的模块。**

将路由抽离为单独模块的步骤如下： 

① 创建路由模块对应的 .js 文件 

② 调用 **express.Router()** 函数创建路由对象 

③ 向路由对象上挂载具体的路由 

④ 使用 **module.exports** 向外共享路由对象

⑤ 使用 **app.use()** 函数注册路由模块

#### 3. 创建路由模块

![](ph/Node/Snipaste_2023-07-10_14-34-03.png)

#### 4. 注册路由模块

![](ph/Node/Snipaste_2023-07-10_14-35-10.png)

#### 5. 为路由模块添加前缀

> 类似于托管静态资源时，为静态资源统一挂载访问前缀一样，路由模块添加前缀的方式也非常简单：

![](ph/Node/Snipaste_2023-07-10_14-36-30.png)



## Express 中间件

### 中间件的概念

#### 1. 什么是中间件

> 中间件（Middleware ），特指**业务流程**的**中间处理环节**

#### 2.  现实生活中的例子

![](ph/Node/Snipaste_2023-07-10_14-41-13.png)

#### 3. Express 中间件的调用流程

> 当一个请求到达 Express 的服务器之后，可以连续调用多个中间件，从而对这次请求进行**预处理**

![](ph/Node/Snipaste_2023-07-10_14-42-47.png)

#### 4. Express 中间件的格式

> Express 的中间件，**本质**上就是一个 **function 处理函数**，Express 中间件的格式如下：

![](ph/Node/Snipaste_2023-07-10_14-45-48.png)

#### 5. next 函数的作用

> **next 函数**是实现**多个中间件连续调用**的关键，它表示把流转关系**转交**给下一个**中间件**或**路由**。

![](ph/Node/Snipaste_2023-07-10_14-47-18.png)

### Express 中间件的用法

#### 1. 定义中间件函数

> 可以通过如下的方式，定义一个最简单的中间件函数:

![](ph/Node/Snipaste_2023-07-10_14-50-04.png)

##### 常用的Express中间件属性和方法：

- `req`: 请求对象，包含有关HTTP请求的信息，例如请求头、请求体等。
- `res`: 响应对象，包含有关HTTP响应的信息，例如响应头、响应体等。
- `next`: 一个函数，调用它会将控制权交给下一个中间件。如果没有调用`next`，则请求将被挂起。

以下是一些常用的中间件方法：

- `app.use()`: 使用中间件函数。可以使用一个或多个中间件函数。
- `app.get()`: 处理GET请求。
- `app.post()`: 处理POST请求。
- `app.put()`: 处理PUT请求。
- `app.delete()`: 处理DELETE请求。

#### 2. 全局生效的中间件

> 客户端发起的**任何请求**，到达服务器之后，**都会触发的中间件**，叫做全局生效的中间件。 通过调用 **app.use(中间件函数)**，即可定义一个**全局生效**的中间件，示例代码如下：

![](ph/Node/Snipaste_2023-07-10_14-53-06.png)

#### 3. 定义全局中间件的简化形式

![](ph/Node/Snipaste_2023-07-10_14-55-10.png)

#### 4. 中间件的作用

> 多个中间件之间，**共享同一份 req** **和 res**。基于这样的特性，我们可以在**上游**的中间件中，**统一**为 req 或 res 对象添 加**自定义**的**属性**或**方法**，供**下游**的中间件或路由进行使用

![](ph/Node/Snipaste_2023-07-10_14-57-24.png)

#### 5. 定义多个全局中间件

> 可以使用 app.use() **连续定义多个**全局中间件。客户端请求到达服务器之后，会按照中间件**定义的先后顺序**依次进行 调用，示例代码如下:

![](ph/Node/Snipaste_2023-07-10_14-58-51.png)

#### 6. 局部生效的中间件

> **不使用 app.use()** 定义的中间件，叫做**局部生效的中间件**，示例代码如下：

![](ph/Node/Snipaste_2023-07-10_15-01-02.png)

#### 7. 定义多个局部中间件

> 可以在路由中，通过如下两种**等价**的方式，**使用多个局部中间件:**

![](ph/Node/Snipaste_2023-07-10_15-02-28.png)

#### 8. 了解中间件的5个使用注意事项

① 一定要在**路由之前**注册中间件 

② 客户端发送过来的请求，**可以连续调用多个**中间件进行处理

 ③ 执行完中间件的业务代码之后，**不要忘记调用 next() 函数** 

④ 为了**防止代码逻辑混乱**，调用 next() 函数后不要再写额外的代码 

⑤ 连续调用多个中间件时，多个中间件之间，**共享** req 和 res 对象

### 中间件的分类

> Express 官方把**常见的中间件用法**，分成了 **5 大类**，分别是：

① **应用级别**的中间件

② **路由级别**的中间件 

③ **错误级别**的中间件

④ **Express 内置**的中间件

⑤ **第三方**的中间件

#### 1. 应用级别的中间件

> 通过 **app.use()** 或 **app.get()** 或 **app.post()** ，**绑定到 app 实例上的中间件**，叫做应用级别的中间件，代码示例如下：

![](ph/Node/Snipaste_2023-07-10_15-11-36.png)

#### 2. 路由级别的中间件

绑定到 **express.Router()** 实例上的中间件，叫做路由级别的中间件。它的用法和应用级别中间件没有任何区别。只不 过，**应用级别中间件是绑定到 app 实例上，路由级别中间件绑定到 router 实例上**，代码示例如下：

![](ph/Node/Snipaste_2023-07-10_15-14-03.png)

#### 3. 错误级别的中间件

> 错误级别中间件的**作用**：专门用来捕获整个项目中发生的异常错误，从而防止项目异常崩溃的问题。 
>
> **格式：**错误级别中间件的 function 处理函数中，**必须有 4 个形参**，形参顺序从前到后，分别是 (**err**, req, res, next)。

![](ph/Node/Snipaste_2023-07-10_15-16-30.png)

#### 4. Express内置的中间件

自 Express 4.16.0 版本开始，Express 内置了 **3 个**常用的中间件，极大的提高了 Express 项目的开发效率和体验： 

① **express.static** 快速托管静态资源的内置中间件，例如： HTML 文件、图片、CSS 样式等（无兼容性）

② **express.json** 解析 JSON 格式的请求体数据（**有兼容性**，仅在 4.16.0+ 版本中可用） 

③ **express.urlencoded** 解析 URL-encoded 格式的请求体数据（**有兼容性**，仅在 4.16.0+ 版本中可用）

![](ph/Node/Snipaste_2023-07-10_15-20-19.png)

#### 5. 第三方的中间件

> 非 Express 官方内置的，而是由第三方开发出来的中间件，叫做第三方中间件。可以按需下载并配置 第三方中间件，从而提高项目的开发效率。

例如：在 express@4.16.0 之前的版本中，经常使用 body-parser 这个第三方中间件，来解析请求体数据。使用步 骤如下：

① 运行 **npm install body-parser** 安装中间件 

② 使用 **require** 导入中间件 

③ 调用 **app.use()** 注册并使用中间件

**注意：**Express 内置的 express.urlencoded 中间件，就是基于 body-parser 这个第三方中间件进一步封装出来的

==补充:==`req.body` 是一个 Node.js 中的对象，它包含了一个 HTTP POST 请求的参数。当使用 `body-parser` 中间件时，会将 POST 请求的数据解析为 `req.body` 对象。因此，我们可以使用 `req.body` 来访问 POST 请求中的数据。

### 自定义中间件

#### 1. 需求描述与实现步骤

![](ph/Node/Snipaste_2023-07-10_15-27-32.png)

#### 2. 定义中间件

> 使用 app.use() 来定义全局生效的中间件，代码如下：

```js
app.use(function(req,res,next){
  //	中间件的业务逻辑
})
```

#### 3. 监听 req 的 data 事件

> 在中间件中，需要监听 req 对象的 data 事件，来获取客户端发送到服务器的数据。
>
>  如果数据量比较大，无法一次性发送完毕，则客户端会**把数据切割后，分批发送到服务器**。所以 data 事件可能会触发多次，每一次触发 data 事件时，**获取到数据只是完整数据的一部分**，需要手动对接收到的数据进行拼接

![](ph/Node/Snipaste_2023-07-10_15-31-46.png)

#### 4. 监听 req 的 end 事件

> 当请求体数据**接收完毕**之后，会自动触发 req 的 end 事件。 因此，我们可以在 req 的 end 事件中，**拿到并处理完整的请求体数据**。示例代码如下

![](ph/Node/Snipaste_2023-07-10_15-34-43.png)

#### 5.  使用 querystring 模块解析请求体数据

> Node.js 内置了一个 **querystring** 模块，**专门用来处理查询字符串**。通过这个模块提供的 **parse()** 函数，可以轻松把 查询字符串，解析成对象的格式。示例代码如下：

![](ph/Node/Snipaste_2023-07-10_15-37-05.png)

#### 6. 将解析出来的数据对象挂载为 req.body

> **上游**的**中间件**和**下游**的**中间件及路由**之间，**共享同一份 req 和 res**。因此，我们可以将解析出来的数据，挂载为 req  的自定义属性，命名为 **req.body**，供下游使用。示例代码如下：

![](ph/Node/Snipaste_2023-07-10_15-38-57.png)

#### 7. 将自定义中间件封装为模块

> 为了优化代码的结构，我们可以把自定义的中间件函数，封装为独立的模块，示例代码如下:

![](ph/Node/Snipaste_2023-07-10_15-39-46.png)

## 使用 Express 写接口

### 4.1 创建基本的服务器

![](ph/Node/Snipaste_2023-07-13_13-46-54.png)

### 4.2 创建 API 路由模块

![](ph/Node/Snipaste_2023-07-13_13-48-54.png)

### 4.3 编写 GET 接口

![](ph/Node/Snipaste_2023-07-13_13-49-30.png)

### 4.4 编写 POST 接口

![](ph/Node/Snipaste_2023-07-13_14-05-22.png)

> 注意：如果要获取 URL-encoded 格式的请求体数据，必须配置中间件 app.use(**express.urlencoded**({ extended: false })）

### 4.5 CORS 跨域资源共享

#### 1. 接口的跨域问题

> 上面的编写的 GET 和 POST接口，存在一个很严重的问题：**不支持跨域请求。**

解决接口跨域问题的方案主要有两种：

① **CORS**（主流的解决方案，**推荐使用**） 

② **JSONP**（有缺陷的解决方案：只支持 GET 请求）

#### 2. 使用 cors 中间件解决跨域问题

cors 是 Express 的一个第三方中间件。通过安装和配置 cors 中间件，可以很方便地解决跨域问题。 

使用步骤分为如下 3 步： 

① 运行 **npm install cors** *安装中间件*

② 使用 **const cors = require('cors') ** *导入中间件*

③ 在路由之前**调用 app.use(cors())** *配置中间件*

#### 3. 什么是 CORS

> CORS （Cross-Origin Resource Sharing，跨域资源共享）由一系列 **HTTP 响应头**组成，**这些 HTTP 响应头决定 浏览器是否阻止前端 JS 代码跨域获取资源。**

> 浏览器的**同源安全策略**默认会阻止网页“跨域”获取资源。但如果接口服务器**配置了 CORS 相关的 HTTP 响应头**， 就可以**解除浏览器端的跨域访问限制。**

![](ph/Node/Snipaste_2023-07-13_14-12-43.png)

#### 4. CORS 的注意事项

① CORS 主要在**服务器端**进行配置。客户端浏览器**无须做任何额外的配置**，即可请求开启了 CORS 的接口。 

② CORS 在浏览器中**有兼容性**。只有支持 XMLHttpRequest Level2 的浏览器，才能正常访问开启了 CORS 的服务端接口（例如：IE10+、Chrome4+、FireFox3.5+）

#### 5. CORS 响应头部 - Access-Control-Allow-Origin

> 响应头部中可以携带一个 **Access-Control-Allow-Origin** 字段，其语法如下:

```js
Access-Control-Allow-Origin: <origin> | *
  //	其中，origin 参数的值指定了允许访问该资源的外域 URL。
  
//	例如，下面的字段值将只允许来自 http://itcast.cn 的请求：
res.setHeader('Access-Control-Allow-Origin','http://itcast.cn')
```

> 如果指定了 Access-Control-Allow-Origin 字段的值为**通配符 ***，表示允许来自任何域的请求，示例代码如下：

```js
res.setHeader('Access-Control-Allow-Origin','*')
```

#### 6. CORS 响应头部 - Access-Control-Allow-Headers

> 默认情况下，CORS 仅支持客户端向服务器发送如下的 9 个请求头：

```js
Accept、Accept-Language、Content-Language、DPR、Downlink、Save-Data、Viewport-Width、Width 、
Content-Type 
//（值仅限于 text/plain、multipart/form-data、application/x-www-form-urlencoded 三者之一）
```

> 如果客户端向服务器**发送了额外的请求头信息**，则需要在**服务器端**，通过 Access-Control-Allow-Headers 对**额外 的请求头进行声明**，否则这次请求会失败

![](ph/Node/Snipaste_2023-07-13_14-22-13.png)

#### 7. CORS 响应头部 - Access-Control-Allow-Methods

> 默认情况下，CORS 仅支持客户端发起 GET、POST、HEAD 请求。

> 如果客户端希望通过 **PUT、DELETE** 等方式请求服务器的资源，则需要在服务器端，通过 Access-Control-Alow-Methods 来**指明实际请求所允许使用的 HTTP 方法。**

![](ph/Node/Snipaste_2023-07-13_14-32-54.png)

#### 8. CORS请求的分类

> 客户端在请求 CORS 接口时，根据**请求方式**和**请求头**的不同，可以将 CORS 的请求分为**两大类**，分别是： 

① 简单请求 

② 预检请求

#### 9. 简单请求

> 同时满足以下两大条件的请求，就属于简单请求：

① **请求方式：**GET、POST、HEAD 三者之一 

② **HTTP 头部信息**不超过以下几种字段：**无自定义头部字段**、Accept、Accept-Language、Content-Language、DPR、 Downlink、Save-Data、Viewport-Width、Width 、Content-Type（只有三个值application/x-www-formurlencoded、multipart/form-data、text/plain

#### 10. 预检请求

> 只要符合以下任何一个条件的请求，都需要进行预检请求：

 ① 请求方式为 **GET、POST、HEAD 之外的请求 Method 类型** 

② 请求头中**包含自定义头部字段** 

③ 向服务器发送**了 application/json 格式的数据**

> 在浏览器与服务器正式通信之前，浏览器**会先发送 OPTION 请求进行预检，以获知服务器是否允许该实际请求**，所以这一 次的 OPTION 请求称为“预检请求”。**服务器成功响应预检请求后，才会发送真正的请求，并且携带真实数据**

#### 11. 简单请求和预检请求的区别

**简单请求的特点：**客户端与服务器之间**只会发生一次请求。**

**预检请求的特点：**客户端与服务器之间会发生两次请求，**OPTION 预检请求成功之后，才会发起真正的请求**

###  JSONP 接口

#### 1. 回顾 JSONP 的概念与特点

> **概念：**浏览器端通过 <script> 标签的 src 属性，请求服务器上的数据，同时，服务器返回一个函数的调用。这种请求数据
> 的方式叫做 JSONP。

> **特点:**

① JSONP 不属于真正的 Ajax 请求，因为它没有使用 XMLHttpRequest 这个对象。

 ② JSONP 仅支持 GET 请求，不支持 POST、PUT、DELETE 等请求

#### 2. 创建 JSONP 接口的注意事项

> 如果项目中**已经配置了 CORS** 跨域资源共享，为了**防止冲突，必须在配置 CORS 中间件之前声明 JSONP 的接口**。否则 JSONP 接口会被处理成开启了 CORS 的接口。示例代码如下：

![](ph/Node/Snipaste_2023-07-13_14-47-21.png)

#### 3. 实现 JSONP 接口的步骤

**① 获取**客户端发送过来的**回调函数的名字** 

**② 得到要**通过 JSONP 形式**发送给客户端的数据** 

③ 根据前两步得到的数据，**拼接出一个函数调用的字符串** 

④ 把上一步拼接得到的字符串，响应给客户端的 

#### 4. 实现 JSONP 接口的具体代码

![](ph/Node/Snipaste_2023-07-13_14-50-38.png)

#### 5. 在网页中使用 jQuery 发起 JSONP 请求

> 调用 $.ajax() 函数，**提供 JSONP 的配置选项**，从而发起 JSONP 请求，示例代码如下

![](ph/Node/Snipaste_2023-07-13_14-51-29.png)



# 数据库

## 数据库的基本概念

### 什么是数据库

> 数据库（database）是用来**组织、存储和管理**数据的仓库。

### 常见的数据库分类

> 最常见的数据库有如下几个：

- MySQL 数据库（目前使用最广泛、流行度最高的开源免费数据库；Community + Enterprise） 
- Oracle 数据库（收费）
-  SQL Server 数据库（收费）
-  Mongodb 数据库（Community + Enterprise）

> 其中，MySQL、Oracle、SQL Server 属于**传统型数据库**（又叫做：**关系型数据库** 或 **SQL 数据库**），这三者的 设计理念相同，用法比较类似。 
>
> 而 Mongodb 属于**新型数据库**（又叫做：**非关系型数据库** 或 **NoSQL 数据库**），它在一定程度上弥补了传统型 数据库的缺陷

## 安装并配置 MYSQL

[点我跳转](E:\sql安装教程\安装教程 - Windows系统安装MySql)

## MySQL的基本使用

### 使用 MySQL Workbench 管理数据库

#### 1. 创建表

![](ph/Node/Snipaste_2023-07-13_15-07-27.png)

#### 2. 写入数据

![](ph/Node/Snipaste_2023-07-13_15-08-19.png)

### 使用 SQL 管理数据库

#### 1. 什么是 SQL

> SQL（英文全称：Structured Query Language）是**结构化查询语言**，专门用来**访问和处理数据库**的编程语言。能够让 我们**以编程的形式，操作数据库里面的数据。**

三个关键点： 

① SQL 是一门**数据库编程语言** 

② 使用 SQL 语言编写出来的代码，叫做 **SQL 语句**

 ③ SQL 语言**只能在关系型数据库中使用**（例如 MySQL、Oracle、SQL Server）。非关系型数据库（例如 Mongodb） 不支持 SQL 语言

#### 2. SQL 能做什么

![](ph/Node/Snipaste_2023-07-13_15-10-37.png)

#### 3. SQL 学习重点

> 重点掌握如何使用 SQL 从数据表中： 

**查询数据**（select） 、**插入数据**（insert into） 、**更新数据**（update） 、**删除数据**（delete）

> 额外需要掌握的 4 种 SQL 语法：

 **where 条件、and 和 or 运算符、order by 排序、count(*) 函数**

### SQL 的 SELECT 语句

> SELECT 语句用于**从表中查询数据**。执行的结果被存储在一个结果表中（称为**结果集**）。

#### 语法

![](ph/Node/Snipaste_2023-07-13_15-16-35.png)

### SQL 的 INSERT INTO 语句

> **INSERT INTO** 语句用于**向数据表中插入新的数据行**

####  语法

![](ph/Node/Snipaste_2023-07-13_15-18-40.png)

###  SQL 的 UPDATE 语句

> **Update** 语句用于**修改表中的数据**。

#### 语法

![](ph/Node/Snipaste_2023-07-13_15-20-14.png)

### SQL 的 DELETE 语句

> **DELETE** 语句用于删除表中的行。

![](ph/Node/Snipaste_2023-07-13_15-21-13.png)

### SQL 的 WHERE 子句

> WHERE 子句用于**限定选择的标准**。在 **SELECT、UPDATE、DELETE** 语句中，**皆可使用** WHERE 子句来限定选择的标准。

#### 1. 语法

![](ph/Node/Snipaste_2023-07-13_15-23-06.png)

#### 2. 可在 WHERE 子句中使用的运算符

> 下面的运算符可在 WHERE 子句中使用，用来限定选择的标准：

![](ph/Node/Snipaste_2023-07-13_15-24-06.png)

### SQL 的 AND 和 OR 运算符

> AND 和 OR 可**在 WHERE 子语句**中**把两个或多个条件结合起来。**

> AND 表示**必须同时满足多个条件**，相当于 JavaScript 中的 && 运算符，例如 **if (a !== 10 && a !== 20)**

> OR 表示**只要满足任意一个条件即可**，相当于 JavaScript 中的 || 运算符，例如 **if(a !== 10 || a !== 20)**

### SQL 的 ORDER BY 子句

#### 1. 语法

> ORDER BY 语句用于**根据指定的列**对*结果集进行排序。*

> ORDER BY 语句**默认**按照**升序**对记录进行排序。

> 如果按照**降序**对记录进行排序，可以使用 **DESC** 关键字。

#### 2. ORDER BY 子句 - 升序排序

> 对 users 表中的数据，按照 status 字段进行升序排序，示例如下

![](ph/Node/Snipaste_2023-07-13_15-32-45.png)

#### 3. ORDER BY 子句 – 降序排序

> 对 users 表中的数据，按照 id 字段进行降序排序，示例如下：

![](ph/Node/Snipaste_2023-07-13_15-33-12.png)

#### 4. ORDER BY 子句 – 多重排序

> 对 users 表中的数据，先按照 **status** 字段进行*降序排序*，再按照 **username** 的字母顺序，进行*升序排序*，示例如下：

![](ph/Node/Snipaste_2023-07-13_15-34-28.png)

### SQL 的 COUNT(*) 函数

#### 1. 语法

> **COUNT(*)** 函数用于返回*查询结果*的**总数据条数**，语法格式如下：

`select count(*) from 表名称`

#### 2. COUNT(*) 示例

> 查询 users 表中 **status** 为 **0** 的总数据条数：

![](ph/Node/Snipaste_2023-07-13_15-37-49.png)

#### 3. 使用 AS 为列设置别名

> 如果希望给查询出来的列名称设置别名，可以使用 **AS** 关键字，示例如下：

![](ph/Node/Snipaste_2023-07-13_15-38-49.png)

## 在项目中操作 MYSQL

### 安装与配置 mysql 模块

#### 1. ==安装== mysql 模块

> mysql 模块是托管于 npm 上的**第三方模块**。它提供了在 Node.js 项目中**连接**和**操作** MySQL 数据库的能力。 想要在项目中使用它，需要先运行如下命令，将 mysql 安装为项目的依赖包：

`npm install mysql`

#### 2. ==配置== mysql 模块

> 在使用 mysql 模块操作 MySQL 数据库之前，**必须先对 mysql 模块进行必要的配置**，主要的配置步骤如下：

![](ph/Node/Snipaste_2023-07-13_15-49-57.png)

#### 3. 测试 mysql 模块能否正常工作

> 调用 db.query() 函数，指定要执行的 SQL 语句，通过回调函数拿到执行的结果：

![](ph/Node/Snipaste_2023-07-13_15-50-45.png)

### 使用 mysql 模块操作 MySQL 数据库

#### 1. 查询数据

> 查询 users 表中所有的数据：

![](ph/Node/Snipaste_2023-07-13_15-52-20.png)

#### 2. 插入数据

> 向 users 表中新增数据， 其中 **username** 为 **Spider-Man**，**password** 为 **pcc321**。示例代码如下：

![](ph/Node/Snipaste_2023-07-13_15-53-30.png)

#### 3. 插入数据的==便捷方式==

> 向表中新增数据时，如果*数据对象的每个属性*和*数据表的字段***一一对应**，则可以通过如下方式快速插入数据：

![](ph/Node/Snipaste_2023-07-13_15-57-48.png)

#### 4. 更新数据

> 可以通过如下方式，更新表中的数据：

![](ph/Node/Snipaste_2023-07-13_15-58-30.png)

#### 5. 更新数据的==便捷方式==

> 更新表数据时，如果*数据对象的每个属性*和*数据表的字段***一一对应**，则可以通过如下方式快速更新表数据：

![](ph/Node/Snipaste_2023-07-13_16-00-07.png)

#### 6. 删除数据

> 在删除数据时，推荐根据 id 这样的唯一标识，来删除对应的数据。示例如下：

![](ph/Node/Snipaste_2023-07-13_16-01-04.png)

#### 7. ==标记删除==

> 使用 DELETE 语句，会把真正的把数据从表中删除掉。为了保险起见，**推荐使用**<u>标记删除</u>的形式，来**模拟删除的动作**。 

> 所谓的标记删除，就是在表中设置类似于 **status** 这样的**状态字段**，来<u>标记</u>当前这条数据是否被删除。

> 当用户执行了删除的动作时，我们并没有执行 DELETE 语句把数据删除掉，而是执行了 UPDATE 语句，将这条数据对应 的 status 字段标记为删除即可

![](ph/Node/Snipaste_2023-07-13_16-02-52.png)

#### `results.length`和`results.affectedRows`

`results.length`表示查询结果集中的行数，它是一个数字类型的值。

`results.affectedRows`表示受到最后一个INSERT、UPDATE、DELETE语句影响的行数，它也是一个数字类型的值。

两者的区别在于，`results.length`是查询结果集中的行数，而`results.affectedRows`是指受到SQL语句影响的行数。

通常情况下，`results.length`和`results.affectedRows`都会被用来检查数据库操作是否成功，以及操作后影响了多少行数据。



# 身份认证

## web开发模式

> 目前主流的 Web 开发模式有两种，分别是： 

① 基于**服务端渲染**的传统 Web 开发模式 

② 基于**前后端分离**的新型 Web 开发模式

### 1. 服务端渲染的 Web 开发模式

> **服务端渲染的概念：**服务器*发送给客户端的 HTML 页面*，是**在服务器通过字符串的拼接，动态生成的**。因此，客户端不需要使用 Ajax 这样的技术额外请求页面的数据。代码示例如下：

![](ph/Node/Snipaste_2023-07-14_11-48-28.png)

### 2. 服务端渲染的优缺点

优点： 

① **前端耗时少**。因为服务器端负责动态生成 HTML 内容，浏览器只需要直接渲染页面即可。尤其是移动端，更省电。 

② **有利于SEO。**因为服务器端响应的是完整的 HTML 页面内容，所以爬虫更容易爬取获得信息，更有利于 SEO。 

缺点： 

① **占用服务器端资源。**即服务器端完成 HTML 页面内容的拼接，如果请求较多，会对服务器造成一定的访问压力。 

② **不利于前后端分离，开发效率低。**使用服务器端渲染，则*无法进行分工合作*，尤其对于*前端复杂度高*的项目，不利于 项目高效开发

### 3. 前后端分离的 Web 开发模式

> 前后端分离的概念：前后端分离的开发模式，**依赖于 Ajax 技术的广泛应用**。简而言之，前后端分离的 Web 开发模式， 就是**后端只负责提供 API 接口，前端使用 Ajax 调用接口**的开发模式

### 4. 前后端分离的优缺点

优点：

 ① **开发体验好。**前端专注于 UI 页面的开发，后端专注于api 的开发，且前端有更多的选择性。

 ② **用户体验好。**Ajax 技术的广泛应用，极大的提高了用户的体验，可以轻松实现页面的局部刷新。

 ③ **减轻了服务器端的渲染压力。**因为页面最终是在每个用户的浏览器中生成的。 

缺点： 

① **不利于 SEO。**因为完整的 HTML 页面需要在客户端动态拼接完成，所以爬虫对无法爬取页面的有效信息。（解决方 案：利用 Vue、React 等前端框架的 **SSR** （server side render）技术能够很好的解决 SEO 问题！）

### 5. 如何选择 Web 开发模式

> **不谈业务场景而盲目选择使用何种开发模式都是耍流氓。** 

- 比如企业级网站，主要功能是展示而没有复杂的交互，并且需要良好的 SEO，则这时我们就需要使用服务器端渲染； 
- 而类似后台管理项目，交互性比较强，不需要考虑 SEO，那么就可以使用前后端分离的开发模式。 

> 另外，具体使用何种开发模式并不是绝对的，为了**同时兼顾**了*首页的渲染速度*和*前后端分离的开发效率*，一些网站采用了 首屏服务器端渲染 + 其他页面前后端分离的开发模式。

## 身份认证

### 1. 什么是身份认证

**身份认证**（Authentication）又称“身份验证”、“鉴权”，是指**通过一定的手段，完成对用户身份的确认。** 

- 日常生活中的身份认证随处可见，例如：高铁的验票乘车，手机的密码或指纹解锁，支付宝或微信的支付密码等。 
-  在 Web 开发中，也涉及到用户身份的认证，例如：各大网站的**手机验证码登录、邮箱密码登录、二维码登录**等

### 2. 为什么需要身份认证

> 身份认证的目的，是为了**确认当前所声称为某种身份的用户，确实是所声称的用户**。例如，你去找快递员取快递，你要怎 么证明这份快递是你的。

### 3. 不同开发模式下的身份认证

对于**服务端渲染**和**前后端分离**这两种开发模式来说，分别有着不同的身份认证方案：

 ① **服务端渲染**推荐使用 *Session 认证机制*

 ② **前后端分离**推荐使用 *JWT 认证机制*

## Session 认证机制

### 1. HTTP 协议的无状态性

> HTTP 协议的无状态性，指的是客户端的**每次 HTTP 请求都是独立的**，连续多个请求之间没有直接的关系，**服务器不会 主动保留每次 HTTP 请求的状态**

![](ph/Node/Snipaste_2023-07-14_12-00-39.png)

### 2. 如何突破 HTTP 无状态的限制

> 对于超市来说，为了方便收银员在进行结算时给 VIP 用户打折，超市可以为每个 VIP 用户发放会员卡。

![](ph/Node/Snipaste_2023-07-14_12-02-05.png)

> 注意：现实生活中的**会员卡身份认证方式**，在 Web 开发中的*专业术语*叫做 **Cookie。**

### 3. 什么是 Cookie

> Cookie 是**存储在用户浏览器中的一段不超过 4 KB 的字符串**。它由一个**名称**（Name）、一个**值**（Value）和其它几个用 于控制 Cookie *有效期、安全性、使用范围*的**可选属性**组成。

> 不同域名下的 Cookie 各自独立，每当客户端发起请求时，会**自动**把**当前域名下**所有**未过期的 Cookie** 一同发送到服务器

**Cookie的几大特性：**

① 自动发送 

② 域名独立 

③ 过期时限 

④ 4KB 限制

### 4. Cookie 在身份认证中的作用

1. 客户端第一次请求服务器的时候，服务器**通过响应头的形式**，向客户端发送一个身份认证的 Cookie，客户端会自动 将 Cookie 保存在浏览器中。
2. 随后，当客户端浏览器每次请求服务器的时候，浏览器会**自动**将身份认证相关的 Cookie，**通过请求头的形式**发送给 服务器，服务器即可验明客户端的身份。

![](ph/Node/Snipaste_2023-07-14_12-10-42.png)

### 5. Cookie 不具有安全性

> 由于 Cookie 是存储在浏览器中的，而且**浏览器也提供了读写 Cookie 的 API**，因此 **Cookie 很容易被伪造**，不具有安全 性。因此不建议服务器将重要的隐私数据，通过 Cookie 的形式发送给浏览器。

**注意**：千万不要使用 Cookie 存储重要且隐私的数据！比如用户的身份信息、密码等。

### 6. 提高身份认证的安全性

> 为了防止客户伪造会员卡，收银员在拿到客户出示的会员卡之后，可以在**收银机上进行刷卡认证**。只有收银机确认存在的 会员卡，才能被正常使用。

![](ph/Node/Snipaste_2023-07-14_12-12-36.png)

### 7. Session 的工作原理

![](ph/Node/Snipaste_2023-07-14_12-14-31.png)

## 在 Express 中使用 Session 认证

### 1. 安装 express-session 中间件

> 在 Express 项目中，只需要安装 **express-session** 中间件，即可在项目中使用 Session 认证：

`npm install express-session`

### 2. 配置 express-session 中间件

> express-session 中间件安装成功后，需要通过 **app.use()** 来**注册 session 中间件**，示例代码如下：

![](ph/Node/Snipaste_2023-07-14_12-16-34.png)

### 3. 向 session 中存数据

> 当 express-session 中间件配置成功后，即可通过 **req.session** 来访问和使用 session 对象，从而存储用户的关键信息：

![](ph/Node/Snipaste_2023-07-14_12-57-52.png)

### 4. 从 session 中取数据

> 可以直接从 **req.session** 对象上获取之前存储的数据，示例代码如下：

![](ph/Node/Snipaste_2023-07-14_12-58-51.png)

### 5. 清空 session

> 调用 **req.session.destroy()** 函数，即可清空服务器保存的 session 信息。

![](ph/Node/w.png)

## JWT 认证机制

### 1. 了解 Session 认证的局限性

> Session 认证机制**需要配合 Cookie 才能实现**。由于 Cookie 默认不支持跨域访问，所以，当涉及到*前端跨域请求后端接 口*的时候，**需要做很多额外的配置**，才能实现跨域 Session 认证。

> 注意： 

-  当前端请求后端接口**不存在跨域问题**的时候，**推荐使用 Session** 身份认证机制。 
- 当前端需要跨域请求后端接口的时候，不推荐使用 Session 身份认证机制，推荐使用 JWT 认证机制。

### 2. 什么是 JWT

> JWT（英文全称：JSON Web Token）是目前*最流行*的**跨域认证解决方案。**

### 3. JWT 的工作原理

![](ph/Node/Snipaste_2023-07-14_13-07-04.png)

> 总结：用户的信息通过 Token 字符串的形式，保存在客户端浏览器中。服务器通过还原 Token 字符串的形式来认证用户的身份。

### 4. JWT 的组成部分

> JWT 通常由三部分组成，分别是 **Header**（头部）、**Payload**（有效荷载）、**Signature**（签名）。 三者之间使用英文的“.”分隔，格式如下：

`Header.Payload.Signature`

> 示例:

`eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6eyJ1c2VybmFtZSI6ImFkbWluIiwicGFzc3dvcmQiOiIwMDAwMDAifSwiaWF0IjoxNjg5MzE0Mjc3LCJleHAiOjE2ODkzMTQzMDd9.oyjzTGvlncm8IwIImUyPHP2XSTtDa2otXIN61O77a58`

### 6. JWT 的三个部分各自代表的含义

> JWT 的三个组成部分，从前到后分别是 Header、Payload、Signature。

其中： 

- **Payload** 部分**才是真正的用户信息**，它是用户信息经过加密之后生成的字符串。 
- Header 和 Signature 是**安全性相关**的部分，只是为了保证 Token 的安全性。

![](ph/Node/Snipaste_2023-07-14_14-01-12.png)

### 7. JWT 的使用方式

> 客户端收到服务器返回的 JWT 之后，通常会将它储存在 *localStorage* 或 *sessionStorage* 中。

> 此后，客户端每次与服务器通信，都要带上这个 JWT 的字符串，从而进行身份认证。推荐的做法是**把 JWT 放在 HTTP  请求头的 Authorization 字段中**，格式如下：

`Authorization: Bearer <token>`

## 在 Express 中使用 JWT

### 1. 安装 JWT 相关的包

> 运行如下命令，安装如下两个 JWT 相关的包：

`npm i jsonwebtoken express-jwt`

其中： 

- **jsonwebtoken** 用于生成 JWT 字符串 
-  **express-jwt** 用于将 JWT 字符串解析还原成 JSON 对象

### 2. 导入 JWT 相关的包

> 使用 **require()** 函数，分别导入 JWT 相关的两个包：

```js
// 1. 导入用户生成 JWT 字符串的包
const jwt = require('jsonwebtoken')
// 2. 导入用于将客户端发送过来的 JWT 字符串,解析还原成 JSON对象的包
const expressJWT = require('express-jwt')
```

### 3. 定义 secret 密钥

> 为了**保证 JWT 字符串的安全性**，防止 JWT 字符串在网络传输过程中被别人破解，我们需要专门定义一个用于**加密**和**解密** 的 secret 密钥：

① 当生成 JWT 字符串的时候，需要使用 secret 密钥对用户的信息**进行加密**，最终得到加密好的 JWT 字符串 

② 当把 JWT 字符串解析还原成 JSON 对象的时候，需要使用 secret 密钥**进行解密**

```js
// secret 秘钥的本质: 就是一个字符串
const secretKey = 'itheima No1 ^_^'
```

### 4. 在登录成功后生成 JWT 字符串

> 调用 *jsonwebtoken* 包提供的 **sign()** 方法，将用户的信息加密成 JWT 字符串，响应给客户端：

![](ph/Node/Snipaste_2023-07-14_14-16-30.png)

### 5. 将 JWT 字符串还原为 JSON 对象

> 客户端每次在访问那些有权限接口的时候，都需要主动通过**请求头中的 Authorization 字段**，将 Token 字符串发 送到服务器进行身份认证。

> 此时，服务器可以通过 *express-jwt* 这个中间件，自动将客户端发送过来的 Token 解析还原成 JSON 对象：

![](ph/Node/Snipaste_2023-07-14_14-18-11.png)

### 6. 使用 req.user 获取用户信息

> 当 express-jwt 这个中间件配置成功之后，即可在那些有权限的接口中，使用 **req.user** 对象，来访问从 JWT 字符串 中解析出来的用户信息了，示例代码如下

![](ph/Node/Snipaste_2023-07-14_14-19-02.png)

### 7. 捕获解析 JWT 失败后产生的错误

> 当使用 express-jwt 解析 Token 字符串时，如果客户端发送过来的 Token 字符串**过期**或**不合法**，会产生一个**解析失败** 的错误，影响项目的正常运行。我们可以通过 **Express 的错误中间件**，捕获这个错误并进行相关的处理，示例代码如下

```js
app.use((err,req,res,next) =>{
  // token 解析失败导致的错误
  if(err.name === 'UnauthorizedError'){
    return res.send({status:401,message:'无效的token'})
  }
  // 其他原因导致的错误
  res.send({status:500,message:'未知错误'})
})
```

